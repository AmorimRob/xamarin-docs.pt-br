|Propriedade|Descrição|Opções|
|--- |--- |--- |
|`abi.type`|**Tipo de ABI** &ndash; Especifica o tipo ABI (interface binária de aplicativo) do dispositivo emulado. O **x86** opção é para o conjunto de instruções normalmente chamado de "x86" ou "IA-32". O **x86_64** opção é para o x86 de 64 bits conjunto de instruções. O **armeabi v7a** opção é para o conjunto de instruções ARM com extensões ARM v7-a. O **arm64 v8a** opção é para o conjunto de instruções de ARM que dá suporte a AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Partição de cache** &ndash; determina se o dispositivo emulado usará um **/cache** partição no dispositivo. O **/cache** partição (que é inicialmente vazia) é o local onde o Android armazena os dados acessados com frequência e componentes de aplicativo. Se definido como **sem**, o emulador não usará um **/cache** partição e o outro `disk.cache` configurações serão ignoradas.|sim, não|
|`disk.cachePartition.path`|**Caminho de partição de cache** &ndash; Especifica um arquivo de imagem de partição de cache no computador de desenvolvimento. O emulador usará esse arquivo para o **/cache** partição. Insira um caminho absoluto ou um caminho relativo ao diretório de dados do emulador do Windows. Se não estiver definida, o emulador cria um arquivo temporário vazio chamado **cache.img** no computador de desenvolvimento. Se o arquivo não existir, será criado como um arquivo vazio. Essa opção será ignorada se `disk.cachePartition` é definido como **sem**.||
|`disk.cachePartition.size`|**Tamanho de partição do cache** &ndash; o tamanho do arquivo de partição de cache (em megabytes). Normalmente, não é necessário definir essa opção, a menos que o aplicativo baixe arquivos muito grandes, maiores que o tamanho padrão do cache, de 66 megabytes. Essa opção será ignorada se `disk.cachePartition` é definido como **sem**.||
|`disk.dataPartition.initPath`|**Caminho inicial para a partição de dados** &ndash; Especifica o conteúdo inicial da partição de dados. Depois de limpar os dados de usuário, o emulador copia o conteúdo do arquivo especificado para dados de usuário (por padrão, **userdata qemu.img**) em vez de usar **userdata.img** como a versão inicial.||
|`disk.dataPartition.path`|**Caminho para a partição de dados** &ndash; Especifica o arquivo de partição de dados de usuário. Para configurar um arquivo de dados de usuário persistente, insira um nome de arquivo e um caminho no computador de desenvolvimento. Se o arquivo não existir, o emulador cria uma imagem do arquivo padrão **userdata.img**, armazena-o no nome de arquivo especificado por `disk.dataPartition.path`, e persistir os dados do usuário quando o emulador é desligado. Se você não especificar um caminho, o arquivo padrão é denominado **qemu.img userdata**. O valor especial  **<temp>**  faz com que o emulador criar e usar um arquivo temporário. Se `disk.dataPartition.initPath` estiver definido, seu conteúdo será copiado para o arquivo disk.dataPartition.path no momento da inicialização. Observe que essa opção não pode ser deixada em branco.||
|`disk.dataPartition.size`|**Tamanho da partição de dados** &ndash; Especifica o tamanho da partição de dados do usuário em megabytes.||
|`disk.ramdisk.path`|**Caminho de RAMDisk** &ndash; caminho para a imagem de inicialização (ramdisk) da partição. A imagem do ramdisk é um subconjunto da imagem do sistema carregada pelo kernel antes de a imagem do sistema ser montada. A imagem do ramdisk normalmente contém binários de tempo de inicialização e scripts de inicialização. Se essa opção não for especificada, o padrão é **ramdisk.img** no diretório do sistema do emulador.||
|`disk.snapStorage.path`|**Caminho de armazenamento de instantâneo** &ndash; caminho para o arquivo de armazenamento de instantâneo onde todos os instantâneos são armazenados. Todos os instantâneos feitos durante a execução serão salvos nesse arquivo. Somente os instantâneos salvos neste arquivo podem ser restaurados durante a execução do emulador. Se essa opção não for especificada, o padrão é snapshots.img no diretório de dados do emulador.||
|`disk.systemPartition.initPath`|**Caminho de inicialização de partição do sistema** &ndash; caminho para a cópia somente leitura do arquivo de imagem do sistema; especificamente, a partição que contém as bibliotecas de sistema e a data correspondente ao nível de API e qualquer variante. Se esse caminho não for especificado, o padrão é system.img no diretório do sistema do emulador.||
|`disk.systemPartition.path`|**Caminho de partição do sistema** &ndash; caminho para a imagem de partição do sistema de leitura/gravação. Se esse caminho não for definido, um arquivo temporário será criado e inicializado do conteúdo do arquivo especificado por `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Tamanho da partição de sistema** &ndash; o tamanho ideal da partição do sistema (em megabytes). O tamanho será ignorado se a imagem da partição do sistema real for maior que essa configuração. Caso contrário, especifica o tamanho máximo que o arquivo de partição do sistema pode atingir.||
|`hw.accelerometer`|**Acelerômetro** &ndash; determina se o dispositivo emulado contém um sensor acelerômetro. O acelerômetro ajuda o dispositivo a determinar orientação (usada para rotação automática). O acelerômetro informa a aceleração do dispositivo em três eixos do sensor.|sim, não|
|`hw.audioInput`|**Suporte de gravação de áudio** &ndash; determina se o dispositivo emulado pode gravar áudio.|sim, não|
|`hw.audioOutput`|**Suporte de reprodução de áudio** &ndash; determina se o dispositivo emulado pode executar o áudio.|sim, não|
|`hw.battery`|**Suporte de bateria** &ndash; determina se o dispositivo emulado pode ser executados em uma bateria.|sim, não|
|`hw.camera`|**Suporte de câmera** &ndash; determina se o dispositivo emulado tem uma câmera.|sim, não|
|`hw.camera.back`|**Câmera voltados para o back** &ndash; configura a câmera voltados para o back (as faces de lente do usuário). Se você estiver usando uma webcam no computador de desenvolvimento para simular a câmera voltados para o back do dispositivo emulado, esse valor deve ser definido como webcam*n*, onde _n_ seleciona a webcam (se você tiver apenas uma webcam, Escolha **webcam0**). Se definido como emulados, o emulador simula a câmera no software. Para desabilitar a câmera voltado para trás, defina esse valor como none. Se você habilitar a câmera voltado para trás, certifique-se de também habilitar `hw.camera`.|emulado, nenhum, webcam0|
|`hw.camera.front`|**Câmera frontal** &ndash; configura a câmera frontal (as faces de lente para o usuário). Se você estiver usando uma webcam no computador de desenvolvimento para simular a câmera frontal do dispositivo emulado, esse valor deve ser definido como webcam*n*, onde _n_ seleciona a webcam (se você tiver apenas uma webcam Escolha **webcam0**). Se definido como emulados, o emulador simula uma câmera no software. Para desabilitar a câmera frontal, defina esse valor como none. Se você habilitar a câmera frontal, certifique-se de também habilitar `hw.camera`.|emulado, nenhum, webcam0|
|`hw.camera.maxHorizontalPixels`|**Pixels de câmera horizontal máximo** &ndash; configura a resolução horizontal máxima da câmera do dispositivo emulado (em pixels).||
|`hw.camera.maxVerticalPixels`|**Pixels de câmera vertical máximo** &ndash; configura a resolução vertical máxima da câmera do dispositivo emulado (em pixels).||
|`hw.cpu.arch`|**Arquitetura de CPU** &ndash; arquitetura da CPU para ser emulada pelo dispositivo virtual. Se você estiver usando o Intel HAXM para aceleração de hardware, selecione **x86** para uma CPU de 32 bits. Selecione **x86_64** para um dispositivo de HAXM acelerado de 64 bits. (Certifique-se de instalar a imagem do sistema Intel x86 correspondente no Gerenciador de SDK: por exemplo, Atom Intel x86 ou Intel x86 Atom_64.) Para simular uma CPU ARM, selecione **arm** de 32 bits ou selecione **arm64** para uma CPU de ARM de 64 bits. Lembre-se que dispositivos virtuais baseados em ARM serão executados de forma muito mais lenta que aqueles baseados em x86, porque a aceleração de hardware não está disponível para ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modelo de CPU** &ndash; esse valor normalmente fica unset (será definido como um valor que é derivado de `hw.cpu.arch` se não for explicitamente definida). No entanto, pode ser definido como uma cadeia de caracteres específicas do emulador para uso experimental.||
|`hw.dPad`|**Chaves de DPad** &ndash; determina se o dispositivo emulado dá suporte a chaves direcional (DPad). Normalmente, um DPad tem quatro chaves para indicar o controle direcional.|sim, não|
|`hw.gps`|**Suporte de GPS** &ndash; determina se o dispositivo emulado tem um receptor GPS (sistema de posicionamento Global).|sim, não|
|`hw.gpu.enabled`|**Emulação de GPU** &ndash; determina se o dispositivo emulado dá suporte a emulação de GPU. Quando habilitada, a emulação de GPU usa o Open GL para Embedded Systems (OpenGL ES) para renderizar gráficos 2D e 3D na tela e a configuração do Modo de Emulação de GPU associada determina como a emulação de GPU é implementada.|sim, não|
|`hw.gpu.mode`|**Modo de emulação de GPU** &ndash; determina como a emulação de GPU é implementada pelo emulador. Se você selecionar automático, o emulador escolherá a aceleração de hardware e software com base na sua configuração do computador de desenvolvimento. Se você selecionar o host, o emulador usará processador de gráfico do seu computador de desenvolvimento para executar a emulação de GPU para renderização mais rápida. Se sua GPU não é compatível com o emulador e no Windows, você pode tentar o ângulo, em vez de host. O modo de ângulo usa DirectX para fornecer um desempenho semelhante ao host. Se você selecionar mesa, o emulador usará a biblioteca de software 3D Mesa para renderizar elementos gráficos. Se você tiver problemas de renderização por meio do processador do seu computador de desenvolvimento gráfico, selecione mesa. O modo de swiftshader pode ser usado para renderizar elementos gráficos no software com desempenho ligeiramente menor do que o uso de GPU do seu computador. A opção off (desabilitar emulação de hardware de elementos gráficos) é uma opção preterida que pode causar a renderização inadequada para alguns itens e, portanto, não é recomendada.|automático, host, mesa, ângulo, swiftshader, off|
|`hw.gsmModem`|**Suporte de modem GSM** &ndash; determina se o dispositivo emulado inclui um modem que oferece suporte ao sistema de rádio de telefonia GSM (Global System for Mobile Communications).|sim, não|
|`hw.initialOrientation`|**Orientação da tela de inicial** &ndash; configura a orientação inicial da tela no dispositivo emulado (modo de retrato ou paisagem). No modo retrato, a tela é mais alta do que larga. No modo paisagem, a tela é mais larga do que alta. Ao executar o dispositivo emulado, é possível alterar a orientação se os modos retrato e paisagem tiverem suporte no perfil do dispositivo.|retrato, paisagem|
|`hw.keyboard`|**Suporte de teclado** &ndash; determina se o dispositivo emulado dá suporte a um teclado QWERTY.|sim, não|
|`hw.keyboard.charmap`|**Nome do teclado charmap** &ndash; o nome do charmap hardware para este dispositivo. Observação: Isso sempre deve ser o padrão **qwerty2** , a menos que você modificou a imagem do sistema adequadamente. Esse nome é enviado para o kernel no momento da inicialização. Usar um nome incorreto resulta em um dispositivo virtual inutilizável.||
|`hw.keyboard.lid`|**Suporte a tampa de teclado** &ndash; se o suporte de teclado é habilitado, essa configuração determina se o teclado QWERTY pode ser fechada/oculto ou aberto/visível. Essa configuração será ignorada se hw.keyboard for definido como false. Observação: o valor padrão é false se o dispositivo emulado tem como alvo o nível de API, 12 ou superior.|sim, não|
|`hw.lcd.backlight`|**Luz de fundo LCD** &ndash; determina se uma luz de fundo LCD é simulada pelo dispositivo emulado.|sim, não|
|`hw.lcd.density`|**Densidade de LCD** &ndash; a densidade da tela de LCD emulada, medida em pixels independentes de densidade ou ponto de distribuição (dp é uma unidade virtual pixels). Quando a configuração é de 160 dp, cada dp corresponde a um pixel físico. Em tempo de execução, o Android usa esse valor para selecionar e dimensionar os recursos/ativos apropriados para a renderização correta da exibição.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profundidade de cor LCD** &ndash; a cor profundidade de bits de framebuffer emulado que contém o bitmap para impulsionar a tela de LCD. Esse valor pode ser 16 bits (65.536 cores possíveis) ou 32 bits (16.777.216 cores e transparência). A configuração de 32 bits pode fazer o emulador ser executado a um ritmo um pouco mais lento, mas com maior precisão de cor.|16, 32|
|`hw.lcd.height`|**Altura em pixel LCD** &ndash; o número de pixels que compõem a dimensão vertical da tela de LCD emulada.||
|`hw.lcd.width`|**A largura em pixels LCD** &ndash; o número de pixels que compõem a dimensão horizontal da tela de LCD emulada.||
|`hw.mainKeys`|**Chaves de domésticos voltar do hardware** &ndash; determina se o dispositivo emulado dá suporte a hardware novamente e botões de navegação de página inicial. Você pode definir esse valor como **Sim** se os botões são implementados apenas no software. Se `hw.mainKeys` é definido como **Sim**, o emulador não exibirá os botões de navegação na tela, mas você pode usar o painel emulador a "pressionar" esses botões.|sim, não|
|`hw.ramSize`|**Tamanho da RAM dispositivo** &ndash; a quantidade de RAM física do dispositivo emulado, em megabytes. O valor padrão será calculado com base no tamanho da tela ou na versão de capa. Aumentar o tamanho pode acelerar a operação do emulador, mas exige mais recursos do computador de desenvolvimento.||
|`hw.screen`|**Tipo de tela de toque** &ndash; define o tipo de tela no dispositivo emulado. Uma tela de multitoque pode controlar dedos de dois ou mais na interface de toque. Uma tela sensível ao toque pode detectar apenas eventos de toque único dedo. Uma tela não sensível ao toque não detectar eventos de toque.|touch, multitouch, sem toque|
|`hw.sdCard`|**Suporte de SDCard** &ndash; determina se o dispositivo emulado dá suporte à inserção e remoção de cartões SD (Secure Digital) virtuais. O emulador usa imagens de disco montável armazenadas no computador de desenvolvimento para simular as partições de dispositivos de cartão SD reais (consulte hw.sdCard.path).|sim, não|
|`sdcard.size`|**Tamanho de SDCard** &ndash; Especifica o tamanho do arquivo no local especificado por cartão SD virtual `hw.sdCard.path`. disponível no dispositivo (em bytes). Se o tamanho for um inteiro simples, ele especificará o tamanho em bytes. Também é possível especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando K, M ou G ao tamanho. O tamanho mínimo é 9 M e o tamanho máximo é de 1023 G.||
|`hw.sdCard.path`|**Caminho da imagem SDCard** &ndash; Especifica o nome de arquivo e o caminho para um arquivo de imagem de partição de cartão SD no computador de desenvolvimento. Por exemplo, esse caminho pode ser definido como **C:\sd\sdcard.img** no Windows.||
|`hw.sensors.magnetic_field`|**Sensor de campo magnética** &ndash; determina se o dispositivo emulado dá suporte a um campo magnética sensor. O sensor de campo magnético (também conhecido como magnetômetro) informa o campo geomagnético do ambiente, conforme medido ao longo de três eixos de sensor. Habilite essa configuração para aplicativos que precisam acessar uma leitura de bússola. Por exemplo, um aplicativo de navegação pode usar esse sensor para detectar a direção que o usuário está seguindo.|sim, não|
|`hw.sensors.orientation`|**Sensor de orientação** &ndash; determina se o dispositivo emulado fornece orientação de valores de sensor. O sensor de orientação mede os graus de rotação de um dispositivo ao redor de todas os três eixos físicos (x, y, z). Observe que o sensor de orientação foi preterido a partir do Android 2.2 (nível da API 8).|sim, não|
|`hw.sensors.proximity`|**Sensor de proximidade** &ndash; determina se o dispositivo emulado dá suporte a um sensor de proximidade. Esse sensor mede a proximidade de um objeto em relação à tela de exibição de um dispositivo. Normalmente, é usado para determinar se um aparelho está próximo ao ouvido de uma pessoa.|sim, não|
|`hw.sensors.temperature`|**Sensor de temperatura** &ndash; determina se o dispositivo emulado dá suporte a um sensor de temperatura. Este sensor mede a temperatura do dispositivo em ° c (&deg;C).|sim, não|
|`hw.touchScreen`|**Suporte a tela sensível ao toque** &ndash; determina se o dispositivo emulado dá suporte a uma tela sensível ao toque. A tela touch é usada para manipulação direta dos objetos na tela.|sim, não|
|`hw.trackBall`|**Suporte de trackball** &ndash; determina se o dispositivo emulado dá suporte a um trackball.|sim, não|
|`hw.useext4`|**Suporte do sistema de arquivo EXT4** &ndash; determina se o dispositivo emulado usa o sistema de arquivos Linux EXT4 para partições. Como agora o tipo de sistema de arquivos é detectado automaticamente, essa opção é preterida e ignorada.|no|
|`kernel.newDeviceNaming`|**A nomenclatura do kernel novo dispositivo** &ndash; usado para especificar se o kernel requer um novo esquema de nomenclatura de dispositivo. Normalmente, é usado com kernels do Linux 3.10 ou posterior. Se definido como **autodetect**, o emulador detectará automaticamente se o kernel requer um novo esquema de nomenclatura de dispositivo.|detecção automática, sim, não|
|`kernel.parameters`|**Parâmetros de kernel** &ndash; Especifica a cadeia de caracteres de parâmetros de inicialização de kernel do Linux. Por padrão, essa configuração é deixada em branco.||
|`kernel.path`|**Caminho de kernel** &ndash; Especifica o caminho para o kernel do Linux. Se esse caminho não for especificado, o emulador procurará no diretório de sistema do emulador para ranchu do kernel.||
|`kernel.supportsYaffs2`|**Suporte de partição YAFFS2** &ndash; determina se o kernel oferece suporte a YAFFS2 partições (ainda outro Flash arquivo sistema 2). Normalmente, isso se aplica somente aos kernels anteriores ao Linux 3.10. Se definido como **autodetect** o emulador detectará automaticamente se o kernel pode montar YAFFS2 sistemas de arquivos.|detecção automática, sim, não|
|`skin.name`|**Nome da capa** &ndash; o nome de uma capa de emulador Android. Uma capa é uma coleção de arquivos que define o visual e os elementos de controle de uma exibição de emulador. Ela descreve a aparência da janela do AVD no computador de desenvolvimento. Uma capa descreve o tamanho de tela, os botões e o design geral, mas não afeta a operação do aplicativo.||
|`skin.path`|**Caminho de capa** &ndash; caminho para o diretório que contém os arquivos de capa do emulador especificado em skin.name Este diretório contém arquivos de layout hardware.ini e arquivos de imagem para os elementos de exibição da capa.||
|`skin.dynamic`|**Capa dinâmico** &ndash; ou não a capa é dinâmica. A capa do emulador é uma capa dinâmica se o emulador criar uma capa de um determinado tamanho com base na altura e largura especificada.|no|

