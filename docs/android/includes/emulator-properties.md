|Propriedade|Descrição|Opções|
|--- |--- |--- |
|`abi.type`|**Tipo de ABI** &ndash; Especifica o tipo ABI (interface binária de aplicativo) do dispositivo emulado. O **x86** opção é para o conjunto de instruções normalmente chamado de "x86" ou "IA-32". O **x86_64** opção é para x86 de 64 bits conjunto de instruções. O **armeabi-v7a** opção é para o conjunto de instruções ARM com extensões ARM v7-a. O **arm64-v8a** opção é para o conjunto de instruções ARM que oferece suporte a AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Partição de cache** &ndash; determina se o dispositivo emulado usará uma **/cache** partição no dispositivo. O **/cache** partição (que é inicialmente vazia) é o local em que o Android armazena os dados acessados com frequência e os componentes do aplicativo. Se definido como **nenhuma**, o emulador não usará um **/cache** partição e o outro `disk.cache` configurações serão ignoradas.|sim, não|
|`disk.cachePartition.path`|**Caminho da partição de cache** &ndash; Especifica um arquivo de imagem de partição de cache no computador de desenvolvimento. O emulador usará esse arquivo para o **/cache** partição. Insira um caminho absoluto ou um caminho relativo ao diretório de dados do emulador. Se não definido, o emulador criará um arquivo temporário vazio chamado **img** no computador de desenvolvimento. Se o arquivo não existir, será criado como um arquivo vazio. Essa opção será ignorada se `disk.cachePartition` é definido como **nenhuma**.||
|`disk.cachePartition.size`|**Tamanho da partição de cache** &ndash; o tamanho do arquivo de partição de cache (em bytes). Normalmente, não é necessário definir essa opção, a menos que o aplicativo baixe arquivos muito grandes, maiores que o tamanho padrão do cache, de 66 megabytes. Essa opção será ignorada se `disk.cachePartition` é definido como **nenhuma**. Se esse valor for um número inteiro, ele especifica o tamanho em bytes. Você também pode especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M**, ou **G** ao valor. O tamanho mínimo é **9 min** e o tamanho máximo é **1023G**.||
|`disk.dataPartition.initPath`|**Caminho inicial para a partição de dados** &ndash; Especifica o conteúdo inicial da partição de dados. Depois de apagar os dados do usuário, o emulador copia o conteúdo do arquivo especificado para dados do usuário (por padrão, **userdata-QEMU**) em vez de usar **UserData** como a versão inicial.||
|`disk.dataPartition.path`|**Caminho para a partição de dados** &ndash; Especifica o arquivo de partição de dados do usuário. Para configurar um arquivo de dados de usuário persistente, insira um nome de arquivo e um caminho no computador de desenvolvimento. Se o arquivo não existir, o emulador criará uma imagem do arquivo padrão **UserData**, armazena-os em nome de arquivo especificado por `disk.dataPartition.path`, e persistir os dados de usuário quando o emulador é desligado. Se você não especificar um caminho, o arquivo padrão é denominado **userdata-QEMU**. O valor especial **<temp>** faz com que o emulador criar e usar um arquivo temporário. Se `disk.dataPartition.initPath` estiver definido, seu conteúdo será copiado para o `disk.dataPartition.path` arquivo no momento da inicialização. Observe que essa opção não pode ser deixada em branco.||
|`disk.dataPartition.size`|**Tamanho da partição de dados** &ndash; Especifica o tamanho da partição de dados de usuário em bytes. Se esse valor for um número inteiro, ele especifica o tamanho em bytes. Você também pode especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M**, ou **G** ao valor. O tamanho mínimo é **9 min** e o tamanho máximo é **1023G**.||
|`disk.ramdisk.path`|**Caminho do RAMDisk** &ndash; caminho para a imagem de inicialização (ramdisk) da partição. A imagem do ramdisk é um subconjunto da imagem do sistema carregada pelo kernel antes de a imagem do sistema ser montada. A imagem do ramdisk normalmente contém binários de tempo de inicialização e scripts de inicialização. Se essa opção não for especificada, o padrão será **RAMDisk** no diretório de sistema do emulador.||
|`disk.snapStorage.path`|**Caminho de armazenamento de instantâneo** &ndash; caminho para o arquivo de instantâneo de armazenamento em que todos os instantâneos são armazenados. Todos os instantâneos feitos durante a execução serão salvos nesse arquivo. Somente os instantâneos salvos neste arquivo podem ser restaurados durante a execução do emulador. Se essa opção não for especificada, o padrão é de snapshots no diretório de dados do emulador.||
|`disk.systemPartition.initPath`|**Caminho de inicialização da partição de sistema** &ndash; caminho para a cópia somente leitura do arquivo de imagem de sistema; especificamente, a partição que contém as bibliotecas do sistema e dados correspondentes ao nível de API e qualquer variante. Se esse caminho não for especificado, o padrão é img no diretório de sistema do emulador.||
|`disk.systemPartition.path`|**Caminho do sistema de partição** &ndash; caminho para a imagem de partição do sistema de leitura/gravação. Se esse caminho não for definido, um arquivo temporário será criado e inicializado nos conteúdos do arquivo especificado por `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Tamanho da partição de sistema** &ndash; o tamanho ideal da partição do sistema (em bytes). O tamanho será ignorado se a imagem da partição do sistema real for maior que essa configuração. Caso contrário, especifica o tamanho máximo que o arquivo de partição do sistema pode atingir. Se esse valor for um número inteiro, ele especifica o tamanho em bytes. Você também pode especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M**, ou **G** ao valor. O tamanho mínimo é **9 min** e o tamanho máximo é **1023G**.||
|`hw.accelerometer`|**Acelerômetro** &ndash; determina se o dispositivo emulado contém um sensor de acelerômetro. O acelerômetro ajuda o dispositivo a determinar orientação (usada para rotação automática). O acelerômetro informa a aceleração do dispositivo em três eixos do sensor.|sim, não|
|`hw.audioInput`|**Suporte de gravação de áudio** &ndash; determina se o dispositivo emulado pode gravar áudio.|sim, não|
|`hw.audioOutput`|**Suporte para reprodução de áudio** &ndash; determina se o dispositivo emulado pode reproduzir áudio.|sim, não|
|`hw.battery`|**Suporte para bateria** &ndash; determina se o dispositivo emulado pode ser executado com bateria.|sim, não|
|`hw.camera`|**Suporte para câmera** &ndash; determina se o dispositivo emulado tem uma câmera.|sim, não|
|`hw.camera.back`|**Câmera traseira** &ndash; configura a câmera traseira (a Lente fica longe do usuário). Se você estiver usando uma webcam no computador de desenvolvimento para simular a câmera traseira no dispositivo emulado, esse valor deve ser definido como o webcam*n*, onde _n_ seleciona a webcam (se você tiver apenas uma webcam, escolher **webcam0**). Se definido como emulada, o emulador simulará a câmera no software. Para desabilitar a câmera traseira, defina esse valor como none. Se você habilitar a câmera traseira, certifique-se de também habilitar `hw.camera`.|emulado, nenhum, webcam0|
|`hw.camera.front`|**Câmera frontal** &ndash; configura a câmera frontal (a Lente fica em direção ao usuário). Se você estiver usando uma webcam no computador de desenvolvimento para simular a câmera frontal no dispositivo emulado, esse valor deve ser definido como o webcam*n*, onde _n_ seleciona a webcam (se você tiver apenas uma webcam Escolha **webcam0**). Se definido como emulada, o emulador simulará uma câmera no software. Para desabilitar a câmera frontal, defina esse valor como none. Se você habilitar a câmera frontal, certifique-se de também habilitar `hw.camera`.|emulado, nenhum, webcam0|
|`hw.camera.maxHorizontalPixels`|**Pixels da câmera na horizontal máxima** &ndash; configura a resolução máxima na horizontal da câmera do dispositivo emulado (em pixels).||
|`hw.camera.maxVerticalPixels`|**Pixels da câmera na vertical máxima** &ndash; configura a resolução máxima na vertical da câmera do dispositivo emulado (em pixels).||
|`hw.cpu.arch`|**Arquitetura de CPU** &ndash; a arquitetura da CPU a ser emulada pelo dispositivo virtual. Se você estiver usando o Intel HAXM para aceleração de hardware, selecione **x86** para uma CPU de 32 bits. Selecione **x86_64** para um dispositivo de 64 bits acelerado por HAXM. (Certifique-se de instalar a imagem de sistema do Intel x86 correspondente no Gerenciador de SDK: por exemplo, Intel x86 Atom ou Intel x86 Atom_64.) Para simular uma CPU ARM, selecione **arm** de 32 bits ou selecione **arm64** para uma CPU ARM de 64 bits. Lembre-se que dispositivos virtuais baseados em ARM serão executados de forma muito mais lenta que aqueles baseados em x86, porque a aceleração de hardware não está disponível para ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modelo da CPU** &ndash; esse valor normalmente resta unset (ele será definido como um valor que é derivado de `hw.cpu.arch` se não for definido explicitamente). No entanto, pode ser definido como uma cadeia de caracteres específicas do emulador para uso experimental.||
|`hw.dPad`|**Chaves DPad** &ndash; determina se o dispositivo emulado dá suporte a chaves direcional (DPad). Normalmente, um DPad tem quatro chaves para indicar o controle direcional.|sim, não|
|`hw.gps`|**Suporte para GPS** &ndash; determina se o dispositivo emulado tem um receptor GPS (Global Positioning System).|sim, não|
|`hw.gpu.enabled`|**Emulação de GPU** &ndash; determina se o dispositivo emulado dá suporte a emulação de GPU. Quando habilitada, a emulação de GPU usa o Open GL para Embedded Systems (OpenGL ES) para renderizar gráficos 2D e 3D na tela e a configuração do Modo de Emulação de GPU associada determina como a emulação de GPU é implementada.|sim, não|
|`hw.gpu.mode`|**Modo de emulação de GPU** &ndash; determina como a emulação de GPU é implementada pelo emulador. Se você selecionar automático, o emulador escolherá a aceleração de hardware e software com base em sua configuração do computador de desenvolvimento. Se você selecionar o host, o emulador usará o processador de gráficos do seu computador de desenvolvimento para executar a emulação de GPU para renderização mais rápida. Se sua GPU não é compatível com o emulador e você estiver usando o Windows, você pode tentar o ângulo, em vez de host. O modo de ângulo usa o DirectX para proporcionar um desempenho semelhante ao host. Se você selecionar a mesa, o emulador usará a biblioteca de software 3D Mesa para renderizar elementos gráficos. Selecione mesa, se você tiver problemas de renderização por meio do processador de gráficos do seu computador de desenvolvimento. O modo de swiftshader pode ser usado para renderizar elementos gráficos no software com desempenho ligeiramente menor que o uso de GPU do computador. A opção off (desabilitar emulação de hardware de gráficos) é uma opção preterida que pode causar a renderização inadequada de alguns itens e, portanto, não é recomendada.|automático, host, mesa, ângulo, swiftshader, off|
|`hw.gsmModem`|**Suporte para modem GSM** &ndash; determina se o dispositivo emulado inclui um modem que oferece suporte ao sistema de rádio de telefonia GSM (Global System for Mobile Communications).|sim, não|
|`hw.initialOrientation`|**Orientação da tela de inicial** &ndash; configura a orientação inicial da tela no dispositivo emulado (modo retrato ou paisagem). No modo retrato, a tela é mais alta do que larga. No modo paisagem, a tela é mais larga do que alta. Ao executar o dispositivo emulado, é possível alterar a orientação se os modos retrato e paisagem tiverem suporte no perfil do dispositivo.|retrato, paisagem|
|`hw.keyboard`|**Suporte para teclado** &ndash; determina se o dispositivo emulado dá suporte a um teclado QWERTY.|sim, não|
|`hw.keyboard.charmap`|**Nome do charmap do teclado** &ndash; o nome do charmap do hardware para este dispositivo. Observação: Essa sempre deverá ser o padrão **qwerty2** , a menos que você tenha modificado a imagem do sistema adequadamente. Esse nome é enviado para o kernel no momento da inicialização. Usar um nome incorreto resulta em um dispositivo virtual inutilizável.||
|`hw.keyboard.lid`|**Suporte para a tampa de teclado** &ndash; se o suporte para teclado estiver habilitado, essa configuração determina se o teclado QWERTY pode ser fechado/oculto ou aberto/visível. Essa configuração será ignorada se HW é definido como false. Observação: o valor padrão é false se o dispositivo emulado tem como alvo o nível da API 12 ou superior.|sim, não|
|`hw.lcd.backlight`|**Luz de fundo LCD** &ndash; determina se uma luz de fundo LCD é simulada pelo dispositivo emulado.|sim, não|
|`hw.lcd.density`|**Densidade de LCD** &ndash; a densidade da tela de LCD emulada, medida em pixels independentes de densidade ou ponto de distribuição (dp é uma unidade virtual de pixel). Quando a configuração é de 160 dp, cada dp corresponde a um pixel físico. Em tempo de execução, o Android usa esse valor para selecionar e dimensionar os recursos/ativos apropriados para a renderização correta da exibição.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Intensidade de cor do LCD** &ndash; a profundidade de bit de cor do framebuffer emulado que contém o bitmap para controlar a tela de LCD. Esse valor pode ser 16 bits (65.536 cores possíveis) ou 32 bits (16.777.216 cores e transparência). A configuração de 32 bits pode fazer o emulador ser executado a um ritmo um pouco mais lento, mas com maior precisão de cor.|16, 32|
|`hw.lcd.height`|**Altura de pixel do LCD** &ndash; o número de pixels que compõem a dimensão vertical da tela de LCD emulada.||
|`hw.lcd.width`|**Largura de pixel do LCD** &ndash; o número de pixels que compõem a dimensão horizontal da tela de LCD emulada.||
|`hw.mainKeys`|**Teclas voltar/tela inicial de hardware** &ndash; determina se o dispositivo emulado dá suporte a voltar do hardware e botões de navegação de página inicial. Você pode definir esse valor **Sim** se os botões forem implementados somente no software. Se `hw.mainKeys` é definido como **Sim**, o emulador não exibirá botões de navegação na tela, mas você pode usar o painel lateral do emulador para "pressionar" esses botões.|sim, não|
|`hw.ramSize`|**Tamanho da RAM do dispositivo** &ndash; a quantidade de RAM física no dispositivo emulado, em megabytes. O valor padrão será calculado com base no tamanho da tela ou na versão de capa. Aumentar o tamanho pode acelerar a operação do emulador, mas exige mais recursos do computador de desenvolvimento.||
|`hw.screen`|**Tipo de tela Touch** &ndash; define o tipo de tela no dispositivo emulado. Uma tela de multitoque pode acompanhar a duas ou mais dedos na interface de toque. Uma tela sensível ao toque pode detectar somente eventos de toque de dedo. Uma tela sem toque não detecta eventos de toque.|touch, multitouch, sem toque|
|`hw.sdCard`|**Suporte para cartão SD** &ndash; determina se o dispositivo emulado dá suporte à inserção e remoção de cartões de SD (Secure Digital) virtuais. O emulador usa imagens de disco montável armazenadas no computador de desenvolvimento para simular as partições de dispositivos de cartão SD reais (consulte sdcard).|sim, não|
|`sdcard.size`|**Tamanho do cartão SD** &ndash; Especifica o tamanho do arquivo no local especificado pelo cartão SD virtual `hw.sdCard.path`. disponível no dispositivo (em bytes). Se esse valor for um número inteiro, ele especifica o tamanho em bytes. Você também pode especificar o tamanho em quilobytes, megabytes e gigabytes acrescentando **K**, **M**, ou **G** ao valor. O tamanho mínimo é **9 min** e o tamanho máximo é **1023G**.||
|`hw.sdCard.path`|**Caminho da imagem de cartão SD** &ndash; Especifica o nome de arquivo e o caminho para um arquivo de imagem de partição de cartão SD no computador de desenvolvimento. Por exemplo, esse caminho pode ser definido como **C:\sd\sdcard.img** no Windows.||
|`hw.sensors.magnetic_field`|**Sensor de campo magnético** &ndash; determina se o dispositivo emulado dá suporte a um sensor de campo magnético. O sensor de campo magnético (também conhecido como magnetômetro) informa o campo geomagnético do ambiente, conforme medido ao longo de três eixos de sensor. Habilite essa configuração para aplicativos que precisam acessar uma leitura de bússola. Por exemplo, um aplicativo de navegação pode usar esse sensor para detectar a direção que o usuário está seguindo.|sim, não|
|`hw.sensors.orientation`|**Sensor de orientação** &ndash; determina se o dispositivo emulado fornece orientação de valores de sensor. O sensor de orientação mede os graus de rotação de um dispositivo ao redor de todas os três eixos físicos (x, y, z). Observe que o sensor de orientação foi preterido a partir do Android 2.2 (nível da API 8).|sim, não|
|`hw.sensors.proximity`|**Sensor de proximidade** &ndash; determina se o dispositivo emulado dá suporte a um sensor de proximidade. Esse sensor mede a proximidade de um objeto em relação à tela de exibição de um dispositivo. Normalmente, é usado para determinar se um aparelho está próximo ao ouvido de uma pessoa.|sim, não|
|`hw.sensors.temperature`|**Sensor de temperatura** &ndash; determina se o dispositivo emulado dá suporte a um sensor de temperatura. Esse sensor mede a temperatura do dispositivo em graus Celsius (&deg;C).|sim, não|
|`hw.touchScreen`|**Suporte de tela sensível ao toque** &ndash; determina se o dispositivo emulado dá suporte a uma tela sensível ao toque. A tela touch é usada para manipulação direta dos objetos na tela.|sim, não|
|`hw.trackBall`|**Suporte para trackball** &ndash; determina se o dispositivo emulado dá suporte a um trackball.|sim, não|
|`hw.useext4`|**Suporte de sistema de arquivos EXT4** &ndash; determina se o dispositivo emulado usa o sistema de arquivos Linux EXT4 para partições. Como agora o tipo de sistema de arquivos é detectado automaticamente, essa opção é preterida e ignorada.|no|
|`kernel.newDeviceNaming`|**Nomenclatura do novo dispositivo kernel** &ndash; usado para especificar se o kernel exige um novo esquema de nomeação de dispositivo. Normalmente, é usado com kernels do Linux 3.10 ou posterior. Se definido como **autodetect**, o emulador detectará automaticamente se o kernel exige um novo esquema de nomeação de dispositivo.|detecção automática, sim, não|
|`kernel.parameters`|**Parâmetros de kernel** &ndash; Especifica a cadeia de caracteres de parâmetros de inicialização de kernel do Linux. Por padrão, essa configuração é deixada em branco.||
|`kernel.path`|**Caminho do kernel** &ndash; Especifica o caminho para o kernel do Linux. Se esse caminho não for especificado, o emulador procura no diretório de sistema do emulador para kernel-ranchu.||
|`kernel.supportsYaffs2`|**Suporte para partição YAFFS2** &ndash; determina se o kernel oferece suporte a YAFFS2 partições (ainda outro Flash File System 2). Normalmente, isso se aplica somente aos kernels anteriores ao Linux 3.10. Se definido como **autodetect** o emulador detectará automaticamente se o kernel pode montar sistemas de arquivos YAFFS2.|detecção automática, sim, não|
|`skin.name`|**Nome de capa** &ndash; o nome de uma capa de Android emulator. Uma capa é uma coleção de arquivos que define o visual e os elementos de controle de uma exibição de emulador. Ela descreve a aparência da janela do AVD no computador de desenvolvimento. Uma capa descreve o tamanho de tela, os botões e o design geral, mas não afeta a operação do aplicativo.||
|`skin.path`|**Caminho de capa** &ndash; caminho para o diretório que contém os arquivos de capa do emulador especificado no skin.name esse diretório contém arquivos de layout de hardware e arquivos de imagem para os elementos de exibição da capa.||
|`skin.dynamic`|**Dinâmica de capa** &ndash; ou não a capa é dinâmica. A capa do emulador é uma capa dinâmica se o emulador criar uma capa de um determinado tamanho com base na altura e largura especificada.|no|

